\documentclass{article}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}
%\usepackage{outlines}
\usepackage{verbatim}
\usepackage{multicol}
\usepackage{subcaption}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%\linespread{1.3}

\begin{document}

\title{The GETAR file format: \\
GEneric Trajectory ARchives}
\author{Matthew Spellings}
\date{\today}

\maketitle

\section{Introduction}
The process of science generally revolves around three processes in sequence: an idea is formed, results are obtained, and conclusions are drawn from the results.
The robustness of our ability to carry out the latter two components of this science pipeline with respect to the ideas we can generate is tied directly to the flexibility and power of our computational tools.
In this document I will discuss a file format which I think should provide sufficient flexibility and power for our use cases while maintaining a simple design and ease of use.

\section{The GETAR Format}
The main idea behind GETAR (GEneric Trajectory ARchives; yes, pronounced like the instrument) files is to simply use standard data archival tools and embed a small amount of metadata into the filename within the archive.
For our purposes, the underlying archive format (.tar.gz, .zip, .7z...) needs to support efficient random access to files and should be relatively common so that generic tools would also be useful; to begin with, we have chosen the zip file format, but it should be straightforward to change in the future if we find drawbacks to the zip format.

\subsection{GETAR Archives}
GETAR files are just normal zip files, the specification of which is available at \url{http://www.pkware.com/documents/casestudies/APPNOTE.TXT}.
The only caveat is that they must be in the ZIP64 format instead of the ``default'' ZIP format; this enables us to create archives larger than 4GB in size.
Data are stored in individual \textbf{records}, which are simply files in the archive with a particular naming scheme.

\subsection{Records}
GETAR records consist of three primary pieces of information:

\begin{itemize}
\item A \textbf{name}, which indicates what attributes the data are intended to represent
\item A \textbf{resolution}, which indicates at what level of detail the data are stored
\item A \textbf{behavior}, which indicates how the data are stored over time
\end{itemize}

\subsubsection{Record Names}
Record names have no restriction or meaning beyond the overlying schema (properties named ``position'' indicate the position of particles, etc.).

\subsubsection{Record Resolutions}
There are three values that resolutions can have, two for binary data and one for text-based data:

\begin{itemize}
\item A \textbf{uniform} resolution indicates that the data are binary and that they represent the entire system.
\item An \textbf{individual} resolution indicates that the data are binary and that they represent individual particles, rigid bodies, types...
\item A \textbf{text} resolution indicates that the data are stored in plaintext and represent the entire system.
\end{itemize}

\subsubsection{Record Behaviors}
Record behaviors indicate how data are stored over time.
There are three defined behaviors for different use cases:

\begin{itemize}
\item \textbf{Discretely varying} - Data are associated with particular times; for example, particle positions in a MD simulation
\item \textbf{Continuously varying} - Data are generated ``asynchronously'' with the simulation; for example, the text printed to standard output during a HOOMD simulation
\item \textbf{Constant} - data are stored only once and do not vary over the simulation
\end{itemize}

\subsection{Archive Storage Paths}
Put briefly, the record behavior indicates the directory within the zip archive where the data are stored and the record name and resolution are encoded in the filename.
In the following paths, \{name\} will correspond to the record name, \{suffix\} will encode the storage mode of the data (determined by the resolution and binary type of the data), and \{index\} is a string which will be discussed further as needed.

Record filename suffices are generated based on the resolution and binary type of the data stored.
They are of the form \{type\}.\{res\}, where res is ``uni'' for uniform properties, ``ind'' for individual properties, and anything else for text properties.
The type field indicates the binary storage mode of the data and is of the form \{chartype\}\{bitsize\}.
Valid values of \{chartype\} are ``i'' for signed integers, ``u'' for unsigned integers, and ``f'' for floating point data.
The \{bitsize\} field is the size of each element in the array of data in bits.
For example, particle positions stored as 32-bit floating point numbers would be named ``position.f32.ind''.
Arbitrary blobs of binary data could be stored as bytestrings as ``blob.u8.uni'' while a JSON-encoded parameters list could be stored simply as ``params.json.''

Discretely varying data are stored in /frames/\{index\}/\{name\}.\{suffix\}, where the index is some meaningful string corresponding to the time of the data.
Continuously varying data are stored in /var/\{name\}.\{suffix\}/\{index\}, where the index is the string representation of a natural number.
Continuously varying quantities must have indices which are sequentially ordered beginning at 0 and are intended to be concatenated for use by readers.
Constant quantities are stored in /\{name\}.\{suffix\} .

Additionally, a prefix can be prepended to paths to differentiate records.
For example, it could be desirable to store the moment of inertia of both individual particles as well as rigid bodies within a system.
In this case, particle moments could be stored in /moment\textunderscore inertia.f32.ind, while rigid body moments could be stored in /rigid\textunderscore body/moment\textunderscore inertia.f32.ind .

\section{The Python Library}
Basically all interaction of the python library is done using objects of type \texttt{gtar.GTAR} with numpy arrays and strings.
\texttt{gtar.GTAR} objects represent an open file handle, which works much like python's \texttt{open()} function.

\begin{verbatim}
import gtar
writeFile = gtar.GTAR('write.zip', 'w')
appendFile = gtar.GTAR('append.zip', 'a')
readFile = gtar.GTAR('read.zip', 'r')
\end{verbatim}

To ensure that files are properly closed after a task, they can also be used as context manager objects:

\begin{verbatim}
with gtar.GTAR('read.zip', 'r') as readFile:
    # do analysis with readFile
    pass
# in this scope, we are sure that the file has been closed
\end{verbatim}

Most use cases for reading can be handled simply via the high-level functions \texttt{gtar.framesWithRecordsNamed}, \texttt{gtar.recordsNamed}, and \texttt{gtar.staticRecordNamed}.
As an example, a visualization script for anisotropic particles with data from a GTAR archive might look something like the following:

\begin{verbatim}
import json
import gtar
import numpy

arch = gtar.GTAR('dump.zip', 'r')
runParams = json.loads(arch.staticRecordNamed('params.json'))
colors = numpy.random.rand((runParams['N'], 4))

frames = [(pos, quat) for (_, (pos, quat))
              in arch.recordsNamed(['position', 'orientation'])]
\end{verbatim}

\end{document}
